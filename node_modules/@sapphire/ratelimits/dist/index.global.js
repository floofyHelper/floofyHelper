"use strict";
var SapphireRatelimits = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    RateLimit: () => RateLimit,
    RateLimitManager: () => RateLimitManager
  });

  // src/lib/RateLimit.ts
  var RateLimit = class {
    constructor(manager) {
      __publicField(this, "remaining");
      __publicField(this, "expires");
      __publicField(this, "manager");
      this.manager = manager;
      this.reset();
    }
    get expired() {
      return this.remainingTime === 0;
    }
    get limited() {
      return this.remaining === 0 && !this.expired;
    }
    get remainingTime() {
      return Math.max(this.expires - Date.now(), 0);
    }
    consume() {
      if (this.limited)
        throw new Error("Cannot consume a limited bucket");
      if (this.expired)
        this.reset();
      this.remaining--;
      return this;
    }
    reset() {
      return this.resetRemaining().resetTime();
    }
    resetRemaining() {
      this.remaining = this.manager.limit;
      return this;
    }
    resetTime() {
      this.expires = Date.now() + this.manager.time;
      return this;
    }
  };
  __name(RateLimit, "RateLimit");

  // ../timer-manager/dist/index.mjs
  var __defProp2 = Object.defineProperty;
  var __defNormalProp2 = /* @__PURE__ */ __name((obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value, "__defNormalProp");
  var __name2 = /* @__PURE__ */ __name((target, value) => __defProp2(target, "name", { value, configurable: true }), "__name");
  var __publicField2 = /* @__PURE__ */ __name((obj, key, value) => {
    __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  }, "__publicField");
  var TimerManager = /* @__PURE__ */ __name(class extends null {
    static setTimeout(fn, delay, ...args) {
      const timeout = setTimeout(() => {
        this.storedTimeouts.delete(timeout);
        fn(...args);
      }, delay);
      this.storedTimeouts.add(timeout);
      return timeout;
    }
    static clearTimeout(timeout) {
      clearTimeout(timeout);
      this.storedTimeouts.delete(timeout);
    }
    static setInterval(fn, delay, ...args) {
      const interval = setInterval(fn, delay, ...args);
      this.storedIntervals.add(interval);
      return interval;
    }
    static clearInterval(interval) {
      clearInterval(interval);
      this.storedIntervals.delete(interval);
    }
    static destroy() {
      for (const i of this.storedTimeouts)
        clearTimeout(i);
      for (const i of this.storedIntervals)
        clearInterval(i);
      this.storedTimeouts.clear();
      this.storedIntervals.clear();
    }
  }, "TimerManager");
  __name2(TimerManager, "TimerManager");
  __publicField2(TimerManager, "storedTimeouts", /* @__PURE__ */ new Set());
  __publicField2(TimerManager, "storedIntervals", /* @__PURE__ */ new Set());

  // src/lib/RateLimitManager.ts
  var _RateLimitManager = class extends Map {
    constructor(time, limit = 1) {
      super();
      __publicField(this, "time");
      __publicField(this, "limit");
      __publicField(this, "sweepInterval");
      this.time = time;
      this.limit = limit;
    }
    acquire(id) {
      return this.get(id) ?? this.create(id);
    }
    create(id) {
      const value = new RateLimit(this);
      this.set(id, value);
      return value;
    }
    set(id, value) {
      this.sweepInterval ?? (this.sweepInterval = TimerManager.setInterval(this.sweep.bind(this), _RateLimitManager.sweepIntervalDuration));
      return super.set(id, value);
    }
    sweep() {
      for (const [id, value] of this.entries()) {
        if (value.expired)
          this.delete(id);
      }
      if (this.size === 0) {
        TimerManager.clearInterval(this.sweepInterval);
        this.sweepInterval = null;
      }
    }
  };
  var RateLimitManager = _RateLimitManager;
  __name(RateLimitManager, "RateLimitManager");
  __publicField(RateLimitManager, "sweepIntervalDuration", 3e4);
  return __toCommonJS(src_exports);
})();
//# sourceMappingURL=index.global.js.map